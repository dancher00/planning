\documentclass[11pt]{article}
\usepackage[letterpaper, margin=1in]{geometry}
\usepackage{graphicx}
\usepackage{amsmath}

\title{PS2: Path Planning with RRT\\4R Manipulator Path Planning}
\author{Danil Belov}
\date{}

\begin{document}

\maketitle

\section{Task 1A: Visualization of Start and Goal States}

\begin{figure}[h]
    \centering
    \includegraphics[width=0.9\textwidth]{task_1a_start_goal.png}
    \caption{Start state (left) and goal state (right) of the 4R manipulator}
    \label{fig:start_goal}
\end{figure}

\subsection*{Comparison of Discretized vs Continuous Orientation Space}

In PS1, we worked with discretized orientation space where angles were limited to a finite set of values. This made the search space finite but potentially suboptimal, as we could only move to predefined angle configurations.

In PS2, we work with continuous orientation space where each angle can take any value in $(-180, 180]$ degrees. This allows for:
\begin{itemize}
    \item Smoother, more natural motion paths
    \item Better path quality and optimality potential
    \item More flexible obstacle avoidance
\end{itemize}

However, continuous space requires:
\begin{itemize}
    \item Sampling-based methods like RRT (since exhaustive search is impossible)
    \item Collision checking along continuous paths, not just at discrete waypoints
    \item More sophisticated distance metrics for nearest neighbor search
\end{itemize}

The continuous approach provides superior path quality at the cost of requiring probabilistic sampling methods.

\section{Task 1B: Random Configurations}

\begin{figure}[h]
    \centering
    \includegraphics[width=0.9\textwidth]{task_1b_random_configs.png}
    \caption{Four random configurations showing both colliding (red) and non-colliding (green) states}
    \label{fig:random_configs}
\end{figure}

\subsection*{Observations on Collision Checking}

The \texttt{check\_collision()} function correctly identifies when the manipulator links intersect with circular obstacles. The function:
\begin{itemize}
    \item Checks all 4 links of the manipulator
    \item Considers proximity to obstacles using the \texttt{collision\_threshold} parameter
    \item Returns \texttt{True} when any link segment is too close to an obstacle
\end{itemize}

From the visualizations, we can see that:
\begin{itemize}
    \item Some configurations place the manipulator in collision-free space (green labels)
    \item Others cause collisions with obstacles (red labels)
    \item The collision detection properly accounts for the entire link geometry, not just joint positions
    \item The algorithm correctly distinguishes between free and colliding configurations
\end{itemize}

\section{Task 2A: Collision Check Between Configurations}

\begin{figure}[h]
    \centering
    \includegraphics[width=0.9\textwidth]{task_2a_collision_check.png}
    \caption{Collision checking between configurations: non-colliding path (left) and colliding path (right)}
    \label{fig:collision_check}
\end{figure}

\subsection*{Implementation}

To check collision between two configurations, I interpolate a sequence of configurations connecting them using \texttt{angle\_linspace()}. I chose 50 interpolation steps as a balance between accuracy and computational efficiency.

This ensures we check configurations approximately every 0.2--0.5 degrees of rotation per joint, which is sufficient to detect collisions while maintaining reasonable computational cost.

The visualization shows:
\begin{itemize}
    \item \textbf{Left}: A non-colliding path between two valid configurations
    \item \textbf{Right}: A path that collides with obstacles in intermediate configurations, even though both endpoints are valid
\end{itemize}

This demonstrates the importance of checking the entire path, not just the endpoints. Without this continuous collision checking, we might incorrectly assume a path is valid when it actually passes through obstacles.

\section{Task 2B: RRT Algorithm Implementation}

\subsection*{Algorithm Components}

The RRT algorithm was implemented with the following components:

\begin{enumerate}
    \item \textbf{Distance Function}: L1 distance (Manhattan distance) between configuration vectors using \texttt{angle\_difference()} to handle angle wraparound.
    
    \item \textbf{Maximum Step Size}: 10 degrees per joint (as suggested in the assignment).
    
    \item \textbf{Goal Bias}: 10\% probability of sampling the goal configuration directly, which helps guide exploration toward the goal.
    
    \item \textbf{Collision Checking}: Uses 50 interpolation steps between configurations to ensure the entire path is collision-free.
    
    \item \textbf{Nearest Neighbor}: Uses L1 distance to find the nearest node in the tree.
    
    \item \textbf{Steering}: Limits each joint's movement to \texttt{max\_angle\_step}, ensuring we don't make too large jumps that might miss narrow passages.
\end{enumerate}

\subsection*{Results}

\begin{itemize}
    \item Successfully found a path from start to goal
    \item Video saved as \texttt{solve\_4R.mp4} showing the complete motion
    \item The algorithm explores the configuration space efficiently using random sampling
\end{itemize}

\section{Task 2C: Statistics and Analysis}

\subsection*{Statistics from RRT Execution}

The main RRT run (Task 2B) produced the following statistics:

\begin{table}[h]
    \centering
    \begin{tabular}{lr}
        \hline
        \textbf{Metric} & \textbf{Value} \\
        \hline
        Goal reached at iteration & 5822 \\
        Tree size (states visited) & 2012 nodes \\
        Final trajectory size & 68 states \\
        Path length (L1 distance) & 2230.18 degrees \\
        \hline
    \end{tabular}
    \caption{RRT execution statistics}
    \label{tab:statistics}
\end{table}

\subsection*{Comments on Optimality}

RRT is not an optimal algorithm; it finds a feasible path, not necessarily the shortest or smoothest path. The algorithm explores the configuration space randomly, which can lead to:
\begin{itemize}
    \item Suboptimal paths with many waypoints
    \item Longer paths than necessary
    \item Non-smooth trajectories
\end{itemize}

The path quality depends on:
\begin{itemize}
    \item Number of iterations (more iterations = better exploration)
    \item Step size (smaller steps = smoother but slower)
    \item Goal bias (higher bias = faster convergence but less exploration)
    \item Random seed (different seeds yield different paths)
\end{itemize}

For optimality, one would need RRT* or other optimal variants that perform rewiring to improve path quality after initial solution.

\subsection*{Observations Across Multiple Runs}

\begin{itemize}
    \item Tree size varies significantly (typically 1500--3000 nodes)
    \item Path length varies but generally finds solutions within 5000--6000 iterations
    \item Some runs require more iterations depending on obstacle configuration
    \item The algorithm is probabilistically complete: given enough iterations, it will find a solution if one exists
\end{itemize}

\section{Task 2D: Distance Weight Analysis}

\subsection*{Distance Weight Experiments}

I tested different weight configurations for the distance function. The results are summarized in Table~\ref{tab:weights}.

\begin{table}[h]
    \centering
    \begin{tabular}{lccc}
        \hline
        \textbf{Weight Configuration} & \textbf{Result} & \textbf{Iterations} & \textbf{Tree Size} \\
        \hline
        Uniform [1, 1, 1, 1] & Success & 1483 & $\sim$271 (at 1000) \\
        Emphasize joint 1 [2, 1, 1, 1] & Failed (max iter) & 10000 & 2657 (at 9000) \\
        Emphasize joints 3--4 [1, 1, 2, 2] & Failed (max iter) & 10000 & 3305 (at 9000) \\
        De-emphasize joints 1--2 [0.5, 0.5, 1.5, 1.5] & Failed (max iter) & 10000 & 3181 (at 9000) \\
        \hline
    \end{tabular}
    \caption{Distance weight experiment results}
    \label{tab:weights}
\end{table}

\subsection*{Analysis}

\begin{enumerate}
    \item \textbf{Uniform weights [1, 1, 1, 1]}:
    \begin{itemize}
        \item Treats all joints equally
        \item Balanced exploration
        \item Found solution very quickly (1483 iterations)
        \item Best performance for this problem
    \end{itemize}
    
    \item \textbf{Emphasize joint 1 [2, 1, 1, 1]}:
    \begin{itemize}
        \item Prioritizes moving the first joint
        \item Slower convergence: reached max iterations without solution
        \item May miss solutions that require other joints to move
    \end{itemize}
    
    \item \textbf{Emphasize joints 3--4 [1, 1, 2, 2]}:
    \begin{itemize}
        \item Prioritizes moving the end effector joints
        \item Also reached max iterations without solution
        \item May be useful if end effector positioning is critical
    \end{itemize}
    
    \item \textbf{De-emphasize joints 1--2 [0.5, 0.5, 1.5, 1.5]}:
    \begin{itemize}
        \item Reduces importance of base joints
        \item Reached max iterations without solution
        \item Less effective for this problem
    \end{itemize}
\end{enumerate}

\subsection*{Comments}

Different weights lead to different exploration strategies. Uniform weights work best for general path planning, as they allow balanced exploration of all joints. Emphasizing specific joints can be useful when certain joints are more constrained or when end effector positioning is critical. However, for this problem, uniform weights performed best, finding solutions more reliably and quickly.

\section{Task 2E: Step Size Analysis}

\subsection*{Step Size Experiments}

I tested different maximum step sizes: 5, 10, 15, and 20 degrees. The results are summarized in Table~\ref{tab:stepsize}.

\begin{table}[h]
    \centering
    \begin{tabular}{lccc}
        \hline
        \textbf{Step Size} & \textbf{Result} & \textbf{Iterations} & \textbf{Tree Size} \\
        \hline
        5.0 degrees & Failed (max iter) & 10000 & 2796 (at 9000) \\
        10.0 degrees (recommended) & Success & 4334 & 1348 (at 4000) \\
        15.0 degrees & Success & 9363 & 2350 (at 9000) \\
        20.0 degrees & Success & 7803 & 1512 (at 7000) \\
        \hline
    \end{tabular}
    \caption{Step size experiment results}
    \label{tab:stepsize}
\end{table}

\subsection*{Analysis}

\begin{enumerate}
    \item \textbf{Step size: 5.0 degrees}
    \begin{itemize}
        \item Reached max iterations without solution
        \item Too small, slow exploration
        \item More precise but requires too many iterations
    \end{itemize}
    
    \item \textbf{Step size: 10.0 degrees (recommended)}
    \begin{itemize}
        \item Found solution at iteration 4334
        \item Good balance between speed and precision
        \item Optimal for this problem
    \end{itemize}
    
    \item \textbf{Step size: 15.0 degrees}
    \begin{itemize}
        \item Found solution at iteration 9363
        \item Acceptable but slower convergence
        \item Less precise exploration
    \end{itemize}
    
    \item \textbf{Step size: 20.0 degrees}
    \begin{itemize}
        \item Found solution at iteration 7803
        \item Faster but less precise
        \item May miss narrow passages
    \end{itemize}
\end{enumerate}

\subsection*{Comments}

\textbf{Smaller step sizes (5--10 degrees)}:
\begin{itemize}
    \item More precise exploration
    \item Better obstacle avoidance in narrow passages
    \item Slower tree growth, requires more iterations
    \item Smoother paths but more waypoints
    \item Better for cluttered environments
\end{itemize}

\textbf{Larger step sizes (15--20 degrees)}:
\begin{itemize}
    \item Faster tree growth, fewer iterations needed
    \item May miss narrow passages
    \item Less precise, potentially less smooth paths
    \item Fewer waypoints but may require post-processing
    \item Better for open spaces
\end{itemize}

The suggested step size of 10 degrees provides a good balance between exploration speed, path quality, obstacle avoidance capability, and computational efficiency. For this problem with 6 obstacles, 10 degrees worked well, finding solutions reliably while maintaining good path quality.

\section{Conclusion}

The RRT algorithm successfully found paths for the 4R manipulator in a cluttered environment. Key findings:
\begin{itemize}
    \item Uniform distance weights perform best for this problem
    \item Step size of 10 degrees provides optimal balance
    \item The algorithm is probabilistically complete but not optimal
    \item Continuous collision checking is essential for path validity
\end{itemize}

The implementation demonstrates the effectiveness of sampling-based planning for high-dimensional continuous configuration spaces.

\end{document}

